## 메모리에 접근하는 비용
메인 메모리는 **느리며**, 메모리에 접근하는 비용은 프로세서의 다름 비용들보다 훨씬 크다.
통상 데스크톱 프로세서가 메민 메모리에서 단일 데리터 워드를 가져오는 시간은 다른 명령어 수백개를 실행할 수 있는 수준이다.
cpu 코어의 수가 늘어나도, 느리기 그지없는  메인메모리를 접근하기 위해 경쟁을 하여 성능개선이 별로 안 될 가능성이 크다(**memory wall**)
그러므로,보통 프로세서와 매우 가까운 곳에 속도가 빠은 임시 저장소, **캐시메모리**를 둬서 이를 보완한다.

## 메모리 접근 방법에 따른 비용
프로세서는 메모리에서 **한 워드씩** 데이터를 읽으며 (64bit 기준 4바이트),
속도를 위해 워드 단위로 데이터를 정렬한다(데이터가 워드가 채 안 될 때는 그 자리는 비워놓는다.)
메모리 절약 등을 위한 목적으로 #pragma pack 등을 사용하여 워드 단위가 아닌,메모리를 한 바이트씩 읽고 처리한다면 
메모리 접근을 위해 드는 시간이 더 걸린다  
(예를 들어, 워드 단위로 읽던 프로세서가 갑자기 1바이트씩 메모리를 읽는다면 int 하나를 읽기 위해 1번만 메모리에 덥근하던 비용이 4번으로 바뀌는 것이다)

## 메모리의 단계
프로세서에서 가장 빠르게 접근할 수 있는 캐시부터 메인메모리,디스크의 가상 메모리 페이지가 있다.
캐시는 L1/L2/L3 레벨의 캐시가 있으며 , 통상 윗 단계의 레벨의 캐시는 아래 단계의 캐시보다 약 10배정도 빠르다.


## 동적변수가 비용이 큰 이유
기계어로 컴파일되는 c++ 의 경우, 대부분의 문장 실행 비용은 몇 번의 메모리 접근정도이다(ns 수준)
그러나 동적 변수의 경우, 메모리 할당을 위해 약 수천 번의 메모리 접근이 필요하다.
따라서 메모리 관리자를 호출하는 횟수 한 번을 줄이는 것조차 함수 성능 향상에 적지않은 도움이 된다.

## 동적 메모리 할당 절차
- 메모리 할당 함수는 요청받은 메모리 블록을 할당하기 위해 빈 메모리 컬렉션을 찾는다.
- 빈 메모리 블록을 찾으면, 빈 메모리 블록 컬렉션에서 블록을 제거하고 반환한다.
  - 만약 함수가 요청한 블록보다 훨씬 큰 블록일 경우, 블록을 분할하고 일부를 반환한다.
- 빈 메모리 블록을 못 찾으면, 할당 함수는 큰 메모리 블록을 얻기 위해 가용 메모리 시스템 풀에서 고비용으로 운영체제 커널을 호출한다
  - 커널에서 할당되는 메모리는 캐시되어있을수도, 아닐수도 있으며 후자의 경우 더 많은 지연시간이 걸린다.

- 빈 메모리 블록의 컬렉션은 모든 스레드가 공유하는 자원이므로, 컬렉션에 관한 변경사항은 **스레드에 안전**해야한다. 따라서 스레드들이 대기하며 역시 비용을 초래한다.
  그러므로 메모리를 반환할 경우에도 역시 스레드 안전에 따른 비용이 든다.
