## 배열 관리 객체

일반적으로 연속된 메모리를 관리하고싶다면, **vector 나 array** 를 사용하는 것이 적합하다.  

이 컨테이너들은 연속된 메모리를 각각 힙과 스택에 생성하여 알아서 잘 관리해준다.

동적할당의 비용을 생각하면 , 배열길이가 고정일 경우 당연히 스택에 메모리를 생성하는 array를 쓰는 것이 더 속도가 빠를것이다.  

스택 사이즈를 넘을만큼 요청한 배열의 사이즈가 클 경우엔 오버플로우를 내지 않고 자동으로 힙에 메모리를 생성한다.

그럼에도 불구하고 굳이 연속된 메모리를 관리하기위해 스마트포인터를 쓰고자한다면   

**배열을 담을 수 있도록 특수화 된 스마트포인터**를 사용해야 한다.  
    
&nbsp;  
    
  
## 배열을 담기에 적합하지 않은 일반 스마트포인터

스마트포인터에 배열이 아닌 단일 포인터를 담듯이 배열을 담아버리면 안 된다.  

메모리를 해제할 때, **delete[] 대신 delete 를 사용해서 해제**해버린다.  

이 경우 첫번째 요소라도 제대로 해제되면 다행이고, 나머지 요소들은 해제되지 못할 것이다.  

따라서 이 경우엔 **삭제자를 제공하여 delete[] 를 통해 메모리를 해제**하게 한다면 문제없다.  

그러나 이 경우엔 **[] 연산자는 지원하지 않는다**    
  &nbsp;
    
    
    
```cpp  
    shared_ptr<Car> p1( new Car[10]); // bug - delete[], [] 연산없음

    shared_ptr<Car> p2( new Car[10], [](Car* p) { delete[] p;} ); // 배열을 위한 삭제자를 람다 함수 형태로 전달

    p2[0].Go(); // error -> [] 연산자는 지원하지 않음
```
&nbsp;

## 배열을 위해 특수화 된 스마트포인터

c++ 17부터 배열도 스마트 포인터에 문제없이 담고 삭제할 수 있도록 배열을 위한 스마트포인터를 특수화했다. 

일반 스마트포인터와는 아예 다른 클래스이며, 관리하는 객체를 **delete[] 연산자를 이용해서 삭제**해주고, 

관리하는 배열에 인덱스로 접근할 수 있도록 **[] 연산자도 지원**한다.  

&nbsp;
```cpp

    shared_ptr<Car[]> p1( new Car[10]); //  delete[],   []연산있음

    p1[0].Go(); // [] 연산 지원

```
