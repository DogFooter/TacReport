## 캡슐화의 중요성

객체지향 패러다임에서 캡슐화의 중요성이란 이루 말 할 수없다.  
모듈끼리의 응집도가 낮아지는 것도 결합도가 높아지는 것도 캡슐화를 제대로 하지 못했기 때문에 발생한다.

같은 클래스를 대상으로 캡슐화가 잘 된 예와 잘 못 된 예를 아주 간단한 코드로 살펴보자
&nbsp;
## 캡슐화의 나쁜 예
 ```java
public class movie {
  private int fee;
    public int getFee(){
      return fee;
  }

  public void setFee(int fee){
    this.fee = fee;
  }
}

 ```

위위 코드는 직접 객체의 내부에 접근할 수 없으므로 캡슐화가 된 것 같지만 ,  
사실은 객체 내부의 정보를 전혀 캡슐화하지 못한다.
사용자는 객체 내부에 멤버변수 fee 가 있다는 것을 명확히 알 수 있으며,  
클래스 작성자는 추후 fee 라는 멤버변수가 변경되면 클래스 멤버함수 전체(getFee 와 setFee)를 모두 수정해야한다.  
이는 객체가 무슨 기능을 하는지보다 객체가 무슨 데이터를 가졌냐에 초점을 맞출 때 흔히 발생한다.  
&nbsp;
## 캡슐화의 좋은 예
 ```java
public class movie {

  private int fee;
   
  public int calculateMovieFee(){
  .....
  }
}

```
&nbsp;
위와 같은 코드는 객체가 가진 데이터보다 기능에 집중을 하여 캡슐화가 된 예를 보여준다.
클라이언트가 직접 get/set을 쓰지 않고 계산된 요금만 리턴받게 함으로써 
내부 구체적인 로직을 숨기면서, 멤버변수인 fee 가 변경되더라도 인터페이스를 크게 수정하지 않아도 된다.

